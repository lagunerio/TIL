## § 1. Docker 복습

### 1. 도커 파일 작성법

#### 예시: HTTP 요청이 오면 "Hello, Kubernetes"라고 응답하는 Go언어 애플리케이션(main.go)을 실행하는 컨테이너 이미지 생성 방법

```Bash
FROM goland:1.14.1-alpine3.11

COPY ./main.go ./

# 컨테이너 내부에서 main.go 빌드
RUN go build -o ./go-app ./main.go

# 실행 계정을 nobody로 지정
USER nobody

# entrypoint: 컨테이너가 기동할 때 실행할 명령어
ENTRYPOINT ["./go-app"]
```

#### 기반 이미지로 사용할 수 있는 대표적인 이미지

|이미지명|이미지 사이즈|설명|
|---|---|---|
|scratch|minimum|shell도 설치되어있지 않아 디버그가 어려움.|
|alpine|small|musl libc와 busybox를 기반으로 한 경량 리눅스.|
|distroless|small|python이나 Node.js 등 특정 애플리케이션 런타임만 포함. [github](https://github.com/GoogleContainerTools/distroless)|
|ubuntu|big||
|centos|big||
|Universal Base Image|big|Red Hat에서 지원하는 Red Hat UBI.|

#### ENTRYPOINT와 CMD 관계

ENTRYPOINT에 기본적으로 바꿀 필요가 없는 부분을 정의해두고, CMD에 기본값 인수 등을 정의하는 것이 일반적이다.
즉, 인수를 지정하고 명령어를 실행하려는 경우에는 CMD 부분만 변경하여 실행할 수 있게 한다.
예를 들어, ```ENTRYPOINT=/bin/sleep, CMD=3600```으로 되어 있으면 컨테이너가 기동할 때 ```/bin/sleep 3600```이 실행된다 (```$ENTRYPONT $CMD``` 형식).
이와 같이 CMD에 sleep하는 시간을 지정하여 사용할 수 있다.

|ENTRYPOINT|CMD|실행되는 명령어|
|---|---|---|
|```"/bin/ls"```|```"-a"```|```/bin/ls -a```|
|```"/bin/ls"```|지정안함|```/bin/ls```|
|지정안함|```/bin/ls```|```/bin/ls```|
|```"/bin/sh", "-c"```|```"ls -a"```|```/bin/sh -c "ls -a"```|

<br>

### 2. 도커 컨테이너 설계

#### # 설계 주의 사항

**[1] 1 컨테이너당 1 프로세스**

기존 가상 머신 환경처럼 하나의 이미지 안에 여러 프로세스를 올리는 방법은 추천하지 않는다.
도커 컨테이너는 애플리케이션과 해당 애플리케이션을 실행하기 위한 실행 환경을 패키징함으로써 애플리케이션을 쉽게 실행하기 위한 도구로, 애플리케이션에서 중요한 역할을 한다.
주변 에코시스템 또한 이를 기반으로 만들어졌기 때문에, 이를 무시하고 도커 컨테이너에 여러 프로세스를 기동하도록 만들면 주변 에코시스템과 맞지 않거나 관리가 힘들어진다.

**[2] 변경 불가능한 인프라(Immutable Infrastructure) 이미지로 생성한다.**

변경 불가능한 인프라는 '환경을 변경할 때 오래된 환경은 없애고 새로운 환경을 만든다. 한번 만들어진 환경은 절대 변경되지 않게 한다.'라는 개념이다.
즉, 컨테이너 기동 후 환경을 구성하는 것이 아니라 외부에서 실행 바이너리를 가져오거나 패키지를 설치하는 등 모든 환경을 구성하여 이미지를 생성한 후 컨테이너를 기동하는 것이 좋다.
도커 컨테이너는 버전을 관리할 수 있으므로 컨테이너 이미지에 관련 리소스를 가능한 한 포함시켜 컨테이너 이미지를 변경 불가능한 상태로 만들어야 한다.

**[3] 경량의 도커 이미지로 생성한다.**

컨테이너를 실행할 때 외부에서 이미지를 pull해서 가져와야 하기 때문에 (노드에 이미지가 없는 경우), 도커 이미지는 가급적 경량으로 만들어야 한다.
- dnf/yum이나 apt로 패키지를 설치한 후 저장소 패키지 목록 등의 캐시 파일 삭제
- 멀티 스테이지 필드를 활용하여 이미지에 필요한 파일만 추가
- 기본 이미지가 경량인 배포판 이미지를 사용: 알파인 리눅스(Alpine Linux), Distroless, 등
- 도커 파일 최적화에 따라 레이어 줄이기
- 도커 이미지를 생성할 때 스쿼시(squash)를 사용하여 이미지를 경량화

**[4] 실행 계정은 root 이외의 사용자로 한다.**

컨테이너 내부에서 프로세스를 기동하는 실행 계정 권한을 최소화하여야 보안 사고를 예방할 수 있다.

<br>

#### (1) 도커 이미지 빌드

** * 멀티 스테이지 빌드**
멀티 스테이지 빌드는 여러 컨테이너 이미지를 사용하여 필요한 계산을 처리한 후, 결과물만 실행용 컨테이너 이미지에 복사라는 구조이다.
컴파일 도구가 포함되어 이미지 사이즈가 매우 커지는 문제가 있을 때, 이걸 사용할 수 있다.
또한, 최근에는 빌드킷(BuildKit) 등을 사용해 빌드 단계의 의존 관계를 자동으로 파악하고 빌드 단계를 병렬로 처리하는 것도 가능하다.

```Bash
# Stage 1 컨테이너: 애플리케이션 컴파일
FROM goland:1.14.1-alpine3.11 as builder
COPY ./main.go ./
RUN go build -o ./go-app ./main.go

# Stage 2 컨테이너: 컴파일한 바이너리를 포함한 실행용 컨테이너 생성
FROM alpine:3.11
# Stage 1에서 컴파일한 결과물을 복사
COPY --from=builder /go-app .
ENTRYPOINT ["./go-app"]
```

#### (2) 이미지 레이어 통합과 이미지 
다이브([Dive](https://github.com/wagoodman/dive))는 도커 이미지(OCI 표준 이미지)를 조사하는 도구다.
각각의 레이어에서 어느 파일에 변경이 있어 어느 정도의 용량이 소비되고 있는지를 CUI에서 조사할 수 있다.

레이어마다 같은 파일의 변경이 많은 경우 docker image build 시 --squash 옵션을 사용하면 최종 파일 상태를 가진 한 개의 레이어에 하나로 합쳐지므로 컨테이너 이미지를 축소할 수 있다.

<br>

## 참고 자료

1. 『쿠버네티스 완벽 가이드』, 마사야 아오야마 지음, 박상욱 옮김
